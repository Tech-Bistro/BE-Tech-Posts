트랜잭션의 고립성 성질은 어떤 트랜잭션에서 지정된 연산이 수행되고 있다면 다른 트랜잭션에 영향을 주거나 받아서는 안된다는 성질입니다.

하지만 트랜잭션을 철저히 격리시키는 것은 성능상의 이슈를 불러오기도 합니다. 

한 트랜잭션이 오랫동안 데이터를 물고 있으면 트랜잭션이 끝날 때 까지 다른 트랜잭션이 간섭하지 못할테니까요 🤔

때문에 트랜잭션은 4가지 수준의 격리 수준을 제시함을 [지난 포스트](https://velog.io/@libienz/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%B4%EB%9E%80)에서 말씀드린 바 있습니다

이번 포스트에서는 예시로 더 자세히 4가지 격리 수준을 설명드림과 동시에 각 격리 수준이 가지고 있는 문제를 자세히 짚어 서비스를 개발하실 때 tradeOff를 고려하여 격리 수준을 선택하실 수 있도록 도와드리겠습니다 🤗

# Read Uncommitted(커밋되지 않은 읽기)
가장 낮은 격리 수준으로 <span style="color:blue">_**한 트랜잭션이 다른 트랜잭션의 커밋되지 않은 데이터가 접근 가능**_</span>한 레벨입니다. 
예시로 함께 보시죠 👍
 
> - $0이 들어있는 계좌에 $100를 입금하려고 하는 트랜잭션 A가 시작
> - 트랜잭션 A에서 계좌의 잔액을 읽어옴 : $0
> - 트랜잭션 A에서 계좌에 $100을 추가 But 커밋을 하지는 않음
> - 동일한 계좌에 $50을 입금하려는 새로운 트랜잭션 B가 시작
> - <span style="color:red">트랜잭션 B에서 계좌의 잔액을 읽어올 때 아직 커밋되지 않은 $100을 읽어온다.</span>


위와 같이 Read Uncomitted는 아직 커밋되지 않은 변경사항도 다른 트랜잭션에서 읽어올 수 있게 한답니다. 

만약 계좌에서 $100를 입금하는 트랜잭션 A가 롤백 되는 경우를 생각해보죠 계좌의 잔액은 $0입니다.
그럼에도 트랜잭션 B에서는 선제적으로 $100를 읽어온 것을 바탕으로 계좌의 잔액을 $100으로 알고 있게 됩니다.

데이터의 일관성이 깨지는 순간이죠 🤔

이처럼 특정 트랜잭션에서 데이터를 변경했지만 아직 커밋되지 않았을 때 다른 트랜잭션에서 해당 값을 조회할 수 있는 경우 문제가 발생할 수 있는 데요 이를 ```Dirty Read```문제라고 합니다 

접근에 제한이 없어 속도는 빠르지만 일관성이 떨어지는 tradeOff가 있네요!

# Read Committed(커밋된 읽기)
두번째로 낮은 격리 수준으로 <span style="color:blue">_**트랜잭션이 커밋된 데이터만 읽을 수 있습니다**_</span> 
다만 한 데이터의 커밋 여부에 따라서 반복적으로 읽었을 때 문제가 있을 수 있는데요 예시로 함께 보시죠 👍
 
> - $0이 들어있는 계좌에 $100를 입금하려고 하는 트랜잭션 A가 시작
> - 트랜잭션 A에서 계좌의 잔액을 읽어옴 : $0
> - 트랜잭션 A에서 계좌에 $100을 추가 But 커밋을 하지는 않음
> - 동일한 계좌에 $50을 입금하려는 새로운 트랜잭션 B가 시작
> - <span style="color:red">트랜잭션 B에서 계좌의 잔액을 읽어올 때 커밋된 값 $0을 읽어온다.</span>

자 이제는 커밋된 값만을 읽어오기에 트랜잭션 A가 롤백이 되더라도 ```Dirty Read```문제로부터는 자유로울 수 있겠네요

하지만 여기에도 문제가 있답니다. 트랜잭션 B에서는 계좌의 잔액을 $0으로 알고있습니다.
하지만 트랜잭션 A가 커밋되고 트랜잭션 B에서 다시 계좌의 잔액을 요청했다고 쳐보죠
커밋된 계좌의 잔액은 $100입니다.

첫번째 요청했을때는 계좌의 잔액이 $0인데 두번째 요청했을때는 계좌의 잔액이 $100이네요!?
같은 데이터를 요청을 했음에도 결과가 다른 모습입니다.

이처럼 트랜잭션 내에서 같은 데이터를 여러 번 조회할 때 읽은 데이터가 서로 다른 값으로 나오는 문제를 ```Non-Repeatable-Read```문제라고 합니다.

# Repeatable Read(반복 가능한 읽기)
세번째 격리 수준으로 <span style="color:blue">_**트랜잭션이 읽은 데이터는 트랜잭션이 완료될 때까지 다른 트랜잭션에 의해 수정되지 않습니다**_</span> 여러 번 읽더라도 동일한 결과를 보장하는 것이지요. 예시로 함께 보시겠습니다 👍

> - $0이 들어있는 계좌에 $100를 입금하려고 하는 트랜잭션 A가 시작
> - 트랜잭션 A에서 계좌의 잔액을 읽어옴 : $0
> - 트랜잭션 A에서 계좌에 $100을 추가 But 커밋을 하지는 않음
> - 동일한 계좌에 $50을 입금하려는 새로운 트랜잭션 B가 시작
> - <span style="color:red">트랜잭션 B에서 계좌의 잔액을 읽어올 때 커밋된 값 $0을 읽어온다.</span>
> - 트랜잭션 A가 커밋. 계좌의 잔액은 $100
> - <span style="color:red">트랜잭션 B가 다시 계좌의 잔액을 읽어와도 $0을 읽어온다.</span>


Repeatable Read는 반복 조회하더라도 이전의 읽은 값을 기반으로 동일한 값을 얻어오도록 설계되어 있네요 
앞서 말씀드린 ```Non-Repeatable-Read```문제로부터는 자유로워보입니다. 

하지만 ```Phantom-Read```문제로부터는 취약합니다!

> #### Phantom Read Problem
> 자신의 세션에서 조회한 자료 세트 범위가 다른 세션에 의해서 변경될 경우 그것이 자신이 조작하지 않았음에도 유령처럼 바뀌는 현상


# Serializable(직렬화)
가장 높은 격리 수준으로, 동시에 실행되는 여러 트랜잭션 간에도 결과가 일관성 있게 유지됩니다. 이는 동시에 <span style="color:blue">_**여러 트랜잭션이 실행되어도 마치 순차적으로 실행되는 것처럼 보이도록 보장**_</span>합니다. 예시로 보시죠!

> - $0이 들어있는 계좌에 $100를 입금하려고 하는 트랜잭션 A가 시작
> - 트랜잭션 A에서 계좌의 잔액을 읽어옴 : $0
> - 트랜잭션 A에서 계좌에 $100을 추가 But 커밋을 하지는 않음
> - 동일한 계좌에 $50을 입금하려는 새로운 트랜잭션 B가 시작
> - <span style="color:red">트랜잭션 B는 트랜잭션 A가 끝날 때 까지 A계좌의 잔액을 읽어올 수 없음
> - 트랜잭션 A가 커밋. 계좌의 잔액은 $100
> - <span style="color:red">트랜잭션 B가 동작한다.</span>

트랜잭션이 완전 종료된 후 다른 트랜잭션이 간섭할 수 있게되었네요 완전한 고립성을 통해서 일관성을 이보다 더 잘 유지할 수 없어보입니다. 다만 미리 말씀드린 것처럼 기다리는 시간이 길어질 수는 있겠죠 🤔

# 정리 
4가지 격리수준과 각 격리 수준이 어떤 문제를 가지고 있는지 설명드렸습니다.
각각 tradeOff가 있었죠

내가 개발하고 있는 서비스 코드가 ```Dirty Read``` 문제가 고려되어야 하는지 ```Non-Repeatable```문제가 고려되어야 하는지 ```Phantom-Read``` 문제가 고려되어야 하는지를 순차적으로 따져보면 현명하게 격리수준을 적용할 수 있겠습니다 🤗
  
# Reference
https://www.postgresql.kr/blog/pg_phantom_read.html

https://tecoble.techcourse.co.kr/post/2022-09-20-external-in-transaction/
