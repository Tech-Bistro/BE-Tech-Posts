
# 📂 목차
>
1. 서블릿이란
2. 서블릿 동작 방식
3. 프론트 컨트롤러 패턴
4. Dispatcher Servlet의 요청 처리 과정
5. 서블릿을 사용하는 스프링 MVC

# 🔍 서블릿이란?

초기 웹어플리케이션들은 클라이언트의 요청에 대해서 정적인 응답만 가능했었다고 합니다 🤔
메뉴판에 있는 메뉴만 제공할 수 있는 음식점과 유사하다고 볼 수 있겠네요 

유저들은 자연스럽게 웹 어플리케이션으로 하여금 자신을 인식하고 맞춤형 서비스를 제공받고 싶은 욕구가 생겼습니다.
하나의 돈까스만 파는집에 ```매운맛 돈까스 주세요```, ```치즈 돈까스 주세요```와 같은 커스텀 요청을 원하게 된 것이죠 🙂

이에 동적 컨텐츠를 제공하는 기술이 생겨났고 서블릿도 동적 컨텐츠를 만드는 기술이라고 볼 수 있습니다.

> [위키백과](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF)
> 자바 서블릿은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 "서블릿"이라 불린다. 자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.


서블릿이 없어도 동적 컨텐츠 서비스를 개발할 수 있습니다. 하지만 서블릿을 사용하면 동적 컨텐츠를 생성하는 웹 서비스를 더욱 편리하게 만들 수 있도록 도와줍니다. 

예시로 보시죠 🤗

![](https://velog.velcdn.com/images/libienz/post/f3a9697c-7131-4c16-b9e8-9bab82b9ea80/image.png)

위 그림은 상품 목록을 요청하는 클라이언트의 HTTP 메시지입니다.   

요청을 수행하기 위해서 서버는 어떤 요청인지, 어떠한 형태로 반환을 원하는지 등등을 HTTP 메시지로 부터 추출해야합니다.

하지만 복잡한 HTTP 메시지로 부터 저희가 직접 요청 정보를 파싱하려면 굉장히 번거로울 것입니다.


![](https://velog.velcdn.com/images/libienz/post/7e08e412-35c3-4af0-bbbb-e2d1aaa0f196/image.png)


위 그림은 서버가 반환하게 될 상품 목록 응답 HTTP 메시지입니다.

결과적으로 저희가 생성해야 하는 응답이죠.

마찬가지로 응답을 생성할 때에도 직접 메타 정보들을 작성하며 HTTP 메시지를 만드려고 하면 굉장히 번거로운 작업이 될 것 같습니다 🧐

서블릿을 사용하게 되면 요청으로부터 응답까지 이어지는 이러한 여러 귀찮은 일들을 미리 정의된 메서드를 통해 처리할 수 있게 됩니다.


![](https://velog.velcdn.com/images/libienz/post/6ed32ca3-83d7-4d28-9e69-b9e8c81f2f9b/image.png)



위의 메서드는 서블릿이 제공하는 메서드들로 요청에 대해서 적용할 수 있는 메서드들 중 일부입니다. URI를 얻고 세션을 얻는 과정등이 메서드로 정의되어 요청 값을 쉽게 파싱할 수 있는 모습이네요 😄


결국 서블릿을 이용하면 여러 귀찮은 일들을 미리 정의된 객체와 메서드로 처리할 수 있게 되고 개발자들은 서비스의 핵심 로직을 개발하는데에 더 깊이 집중할 수 있게 됩니다. 서블릿을 사용할 이유가 충분한 것 같네요 😃

# 📢 서블릿 동작 방식

우선 서블릿은 다음과 같이 생겼습니다. 


![](https://velog.velcdn.com/images/libienz/post/fa05c307-8274-415f-8b49-0c9e5094085c/image.png)



서블릿 마다 요청 처리 로직을 정의하면 특정 요청을 처리할 수 있는 객체가 탄생하게 되죠

서블릿은 특정 요청 하나를 처리하도록 로직이 재정의되기 때문에 여러개가 존재할 수 있으며 여러개의 서블릿 객체는 서블릿 컨테이너에 의해 관리됩니다.


![](https://velog.velcdn.com/images/libienz/post/6621c23b-e846-4e5c-a888-25f26fc7bf21/image.png)


위는 서버에 핫도그를 요청하는 요청 흐름도 입니다. 클라이언트가 핫도그를 요청하면 서블릿 컨테이너는 핫도그 요청을 처리할 수 있는 서블릿을 찾고 핫도그 서블릿이 요청을 처리하여 유저에게 response를 보내는 과정을 보여주고 있습니다.

서블릿 컨테이너는 핫도그 요청을 처리할 수 있는 서블릿을 어떻게 구분할 수 있을까요?


![](https://velog.velcdn.com/images/libienz/post/0198fa61-0469-4cf1-bbd2-3c48af61f864/image.png)



위와 같은 형태로 설정파일을 참고하여 특정 요청을 처리할 수 있는 서블릿을 식별하게 됩니다.

위 설정 파일에서는 ```HelloServlet```이 ```/hello```요청을 처리할 수 있음을 명시하고 서블릿 클래스의 이름과 패키지 정보를 알려주고 있네요

# 👨‍🔧 프론트 컨트롤러 패턴 

서블릿은 특정 요청을 처리하기 위해 재정의(Override)되고 여러개의 서블릿이 존재하며 서블릿 컨테이너에 의해 관리된다고 말씀드렸습니다.

그런데 이렇게 요청마다 서블릿을 작성하여 서블릿 여러개로 관리하면 공통 로직의 중복이 있을 수 있습니다 🧐



![](https://velog.velcdn.com/images/libienz/post/23aa5bf6-efb8-4330-b4a7-34245d09826b/image.png)


요청마다 서블릿을 매핑하여 프론트 컨트롤러 패턴을 도입하지 않은 모습입니다.

각 서블릿에서 주문을 받고 계산하고 포장하고 건네주는 로직이 중복되는 것을 확인할 수 있습니다.

이러한 공통로직을 하나의 객체로 해결할 수 있도록 하는 것이 프론트 컨트롤러 패턴입니다. 주문을 받고 계산하고 포장하고 건네주는 ```매니저```를 두는 것이라고 볼 수 있겠네요



![](https://velog.velcdn.com/images/libienz/post/e3f8e822-eeff-41ab-b235-672b700244fc/image.png)



프론트 컨트롤러 패턴을 적용한 모습입니다. 
공통 로직을 뽑아내어 앞단의 매니저 역할을 맡는 ```Dispatcher Servlet```이 모든 요청을 처리하고 제작을 각 요리사에게 위임하고 있는 모습이에요.

이렇게 공통로직을 분리하게 되면 다음의 장점을 가질 수 있습니다.

> 1. 공통 로직으로 부터 우리가 정말 집중해야 하는 비즈니스 로직을 분리할 수 있다.
> 2. 공통 코드의 처리를 분리함으로써 SRP / OCP원칙을 지킬 수 있다.

# Dispatcher Servlet 웹 요청 처리 과정

프론트 컨트롤러 전략을 도입한 설계가 웹 요청을 어떻게 처리하는지 확인해보겠습니다.

그 전에 더 철저히 역할 분리를 해보죠

이전에 주문, 계산, 포장을 담당하던 Dispatcher Servlet의 역할을 조금 더 줄여보겠습니다.
또 추가적으로 요리사들을 관리하고 호출하는 역할까지 분리해보겠습니다. 


![](https://velog.velcdn.com/images/libienz/post/e2957cbe-3eea-402b-8359-f4de11c7e5e3/image.png)


이제 계산만을 담당하는 매니저와 포장만을 담당하는 매니저까지 분리시켰습니다. 
또 요리사를 호출할 수 있는 매니저까지 분리되었습니다.

계산 포장을 Dispatcher Servlet에서 다른 객체로 책임을 옮기면서 Dispatcher Servlet의 책임이 분리되었고 요리사를 관리하고 호출하는 객체를 분리함으로써 모든 요리사를 동일한 방식으로 관리할 수 있게 되었습니다.

이렇게 까지 분리하면 이제 많은 MVC 프레임워크에서 사용하는 설계와 닮은 모습이 됩니다. SpringMVC도 이러한 형태의 설계를 가지죠 🤗

이러한 설계에서 웹 요청은 다음과 같은 흐름으로 진행됩니다.


![](https://velog.velcdn.com/images/libienz/post/23ea05b9-29cb-4393-8315-9d2f8d7c902d/image.png)


 #### 웹 요청 흐름
1. 유저가 서버로 "/hi"요청을 보냅니다.
2. Dispatcher Servlet이 요청을 받고 해당 요청을 처리할 수 있는 핸들러를 찾습니다.
3. 핸들러를 찾은 Dispatcher Servlet이 Handler Adapter에게 요청 수행을 위임합니다.
4. Handler Adapter는 hi 핸들러를 호출하여 요청을 수행합니다.
5. hi 핸들러가 요청을 처리하고 ModelAndView를 반환합니다.
6. ModelAndView를 요청받은 Dispatcher Servlet이 반환할 뷰를 말아줄 것을 ViewResolver에게 요청합니다.
7. Render된 뷰가 요청자에게 반환됩니다.


# ✨ Dispatcher Servlet을 이용하는 스프링 MVC

자 이렇게 Dispatcher Servlet을 운용하는 경우 웹 요청이 어떠한 방식으로 진행되는지 알아보았습니다.

스프링 MVC도 점진적인 발전을 거쳐서 현재 위에서 설명드린 방식으로 웹 요청을 처리하도록 설계되어 있어요 


![](https://velog.velcdn.com/images/libienz/post/e4964d41-36ce-4fcb-84af-bc5bbd47a51f/image.png)


결과적으로 역할과 책임에 대한 분리가 철저히 이루어졌지만 오히려 복잡해진것 같은 느낌도 듭니다.
항상 무언가를 추상화하려고 할때에는 복잡해진다는 tradeOff가 있는 것 같아요.

하지만 결국 Spring MVC 프레임워크에서 저희가 집중해야 할 부분은 요청을 처리하는 ```핸들러 작성```입니다.

이외의 ```Handler Mapping```, ```Handler Adapter```, ```ViewResolver```는 프레임워크에서 제공할 뿐 저희가 구현해야 할 필요는 없는 것이죠.


결국 스프링으로 웹 요청을 처리하는 것은 스프링 웹 MVC에서 제공하는 Dispatcher Servlet과 웹 요청 처리 관련 구현체들을 사용할 수 있다는 이야기와 동시에 스프링 컨테이너 (IoC)를 사용해서 개발할 수 있다는 이야기가 됩니다.

최종적으로 스프링에서 복잡한 일들을 처리해주고 개발자들로 하여금 비즈니스 로직에 집중할 수 있도록 도와주는 기술이라고 볼 수 있겠네요.





