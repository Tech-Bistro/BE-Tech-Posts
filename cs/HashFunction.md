# 💭 Hash Function
> 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
해시 함수는 무결성 검사, 스토리지 파일 식별, 데이터 베이스 비밀번호 암호화, 블록 체인, 해시 테이블 자료구조 등등 다양한 분야에서 사용되고 있습니다.

자바에서도 해시값과 equals 메서드를 종종 override하곤 하는데요, 저 같은 경우는 해시가 뭔지 모르고 사용하다가 이번에 공부하여 정리해보기로 했습니다.

이번 포스팅에서는 해시 함수를 이용하는 해시 테이블을 예시로 해시 함수의 특징과 좋은 해시 함수의 조건, 해시 충돌등을 알아보겠습니다.

# 🤔 해시 함수를 이용하는 해시 테이블

해시 테이블은 자료를 저장하고 검색하는 시간을 상수시간에 가능하게 하는 자료구조입니다. 
다른 자료구조들과 비교를 해봅시다.

![](https://velog.velcdn.com/images/libienz/post/4616f6da-c0c5-478f-8b15-b692fb237e29/image.png)
배열은 원소를 저장하고 검색하는데에 걸리는 시간이 n에 비례합니다.원소가 많아지면 많아질 수록 저장하고 검색하는데에 시간이 오래걸리니 scalable하다고 말하기는 어려울수도 있겠네요 🤔

![](https://velog.velcdn.com/images/libienz/post/c12a3b81-cb15-4407-907a-333398ec174e/image.png)
트리는 원소를 저장하고 검색하는데 걸리는 시간이 logn에 비례합니다. 그림의 오른쪽과 같은 red black tree(균형 잡힌 트리)같은 경우는 최악의 경우에도 시간 복잡도가 logn을 보장하며 배열보다 시간복잡도가 개선된 모습을 보이지만 여전히 원소수가 많아진다면 부담의 여지가 있습니다.

![](https://velog.velcdn.com/images/libienz/post/64474d81-00c9-4f52-ae21-e3bc639c0067/image.png)
```저장된 자료의 규모에 상관없이 **상수 시간**에 원소들을 접근, 저장 가능하게 할 수는 없을까```와 같은 고민 끝에 등장한 것이 해시 테이블입니다.

이에 해시 테이블의 가장 큰 특징은 저장된 자료의 규모에 상관없이 원소에 대한 접근과 저장을 상수시간에 가능하게 하는 것이라고 볼 수 있습니다.
그리고 이를 가능하게 하는 비법이 바로 **_해시 함수_**입니다.

위 그림에서 h(x)가 해시 함수인데요 10이라는 원소를 해시 함수에 넣으면 2라는 결과가 나옵니다. 이 값을 해시 값, 또는 해시라고 하는데요 해시 테이블은 해시 값을 주소로 하는 위치에 원소를 저장하고 관리함으로써 상수시간 접근을 가능하게 합니다.

말씀드린 해시 테이블의 동작 과정을 요약하면 다음과 같습니다.

> #### 해시 테이블 동작과정
- 원소의 해시값을 해시 함수를 이용하여 계산
- 해시값을 주소로 하는 위치에 원소를 저장
- 검색을 할 때도 원소의 해시값을 계산하여 해당 위치를 조회

배열과 트리는 원소들을 순회하며 같은 원소인지 비교해나가야 하는 반면 해시 테이블은 해시 값을 기반으로 원소의 위치를 상수 시간에 계산할 수 있게 됩니다.


# ⚙️ 해시 함수의 특징

이러한 해시함수는 어떠한 입력에 대해서도 고정된 길이의 데이터로 매핑한다는 특징이 있습니다.
![](https://velog.velcdn.com/images/libienz/post/2bc53ef8-76b9-4bb3-ac67-e359108ff726/image.png)
예시에서 보여드린 위와 같은 해시함수도 어떤 입력이 들어오건 0-7범위를 벗어나지 않는다는 특징이 있죠 
해시함수는 이렇게 고정된 크기를 반환하도록 설계됨으로써 일관성을 지키고 암호학적 요구사항을 충족하도록 합니다.

# ⚙️ 좋은 해시 함수의 특징
해시 함수는 다양한 방식으로 설계될 수 있지만 좋은 해시 함수는 다음의 특징을 가집니다.

> - 계산이 간단하다
> - 서로 다른 입력들에 대해 해시 값이 고르게 분포된다
첫번째로 계산이 간단해야 하는 것은 대량의 데이터나 실시간 처리 시스템에서 효율적으로 동작하기 위해 "고속성"을 가져야 한다는 말입니다. 해시 함수 자체가 복잡하여 시간이 오래걸린다면 해시 함수를 사용하는 의미가 퇴색되기에 해시 함수가 간단해야 한다는 것은 저희가 쉽게 받아들일 수 있는 명제 같습니다.

두번째로 서로 다른 입력들에 대해 해시 값이 고르게 분포되어야 한다는 말은 해시 충돌을 최대한 피해야 한다는 의미와 연관이 있습니다. 이어지는 글에서 해시 충돌에 대해서 설명드리겠습니다.

# 💥 해시 충돌
![](https://velog.velcdn.com/images/libienz/post/24d3e383-55d6-4faf-a692-a4fd49935686/image.png)


위의 해시 함수에 대해서 10, 18, 26은 모두 같은 해시값을 가집니다. 이렇게 서로 다른 원소가 같은 해싱을 거쳤을 때 같은 해시 값을 가지는 상황을 해시 충돌이라고 합니다. 
![](https://velog.velcdn.com/images/libienz/post/48461b89-f84c-4e29-8396-55fcad7bcc77/image.png)

해시 테이블에서는 이렇게 해시 충돌이 발생한 경우 어떻게 원소들을 저장할까요? 해시 충돌을 해결하는 여러 전략이 있습니다. 해시 테이블 예시를 이어가며 해시 충돌 전략들을 설명드리겠습니다.

# 📒 해시 충돌 해결 전략: 체이닝 (Chaining)
해시 충돌을 해결하는 가장 naive한 전략입니다.

같은 주소로 해싱되는 원소를 모두 하나의 연결 리스트로 관리하는 방식입니다.

![](https://velog.velcdn.com/images/libienz/post/6aa8bb38-351a-4310-a6f1-5971c60499e4/image.png)

같은 해시값이면 그냥 같은 주소에 연결리스트로 쭉쭉 매달아 나가는 것이죠

원소를 검색할 때는 해당 연결 리스트의 원소들을 차례로 지나가면서 탐색하게 됩니다.

그림의 해시테이블은 h(x) = x mod 13이라는 해시 함수를 기반으로 합니다.

현재 그림과 같은 상태에서 55를 검색하려고 하면 해시값이 3임을 선제적으로 계산 후 해시값이 3인 주소에 매달려있는 원소들을 지나다니면서 55를 찾는 것이죠

이와 같은 방식은 결국 매달리는 연결리스트의 길이가 길어지면 길어질수록 해싱의 의미가 퇴색되기에 naive하다고 말씀드린 것입니다.

# 📒 해시 충돌 해결 전략: 개방 주소 방법
해시 충돌시 주어진 테이블 공간 안에서 다른 공간을 찾는 방법입니다. 
연결리스트로 매다는 것이 아니라 다른 공간에 들어가는 것이죠

따라서 이 방법은 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장이 없습니다.

개방 주소 방법에는 선형 조사, 이차원 조사, 더블 해싱등이 있습니다. 차례로 하나씩 설명드리겠습니다.

# 📒 개방 주소 방법: 선형 조사 (Linear Probing)
개방 주소 방법 중 가장 간단한 충돌 해결 방법입니다.
충돌이 일어난 자리에서 일차 함수의 보폭으로 점프하며 비어있는 공간을 찾는 방법입니다.

예시로 보시죠

> ![](https://velog.velcdn.com/images/libienz/post/5fc70748-cf05-4039-8e52-a544990ac6b7/image.png)
- 해시 테이블에 18이라는 원소를 저장하려고 했지만 이미 저장되어 있는 원소가 존재하여 해시 충돌이 발생한 상황입니다.
![](https://velog.velcdn.com/images/libienz/post/2c24ec73-17ef-4cf4-852d-2a5e452c6ec2/image.png)
- 그 다음 주소로 점프해보았지만 여전히 자리가 차있는 상황입니다.
![](https://velog.velcdn.com/images/libienz/post/9d91d16b-64c7-4246-89e6-9a38ea226001/image.png)
- 한번 더 점프하여 자신의 주소를 확보한 상황입니다.

이러한 선형 조사 방법은 간단하지만 단점이 있습니다.

일차 함수의 보폭이라는 좁은 보폭으로 점프하게 되기에 충돌이 자주 발생할 경우 값이 들어있는 주소가 한 쪽으로 몰리게 될 수 있습니다.
이렇게 값이 들어있는 주소가 몰리게 될 경우 특정 해시값에서 충돌이 발생했을 때 비어있는 공간을 찾아나서기 까지 오랜시간이 걸리게 될 수 있습니다. 
![](https://velog.velcdn.com/images/libienz/post/a08b7a25-4847-4b37-b6d9-375edab330e6/image.png)

# 📒 개방 주소 방법: 이차원 조사(Quadratic Probing)
선형 조사의 단점을 극복하기 위해 바로 뒷자리를 보는 대신 보폭을 이차 함수로 넓혀 가면서 보는 방식입니다.

특정 영역에 원소가 몰리더라고 그 영역을 빨리 벗어날 수 있습니다.

> #### 보는 순서
1. 계산된 해시값 h(x)
2. h(x) + 1
3. h(x) + 4
4. h(x) + 9
5. h(x) + 16
...
...

이러한 이차원 조사에도 단점이 존재합니다.

같은 해시값을 가지는 원소들은 앞서 배치된 원소들의 점프 자취를 따라갈 수 밖에 없다는 단점입니다.

![](https://velog.velcdn.com/images/libienz/post/895000cf-75d5-4dd5-9948-0e8ef416648e/image.png)


# 📒 개방 주소 방법: 더블 해싱 (Double Hashing)

더블 해싱은 두개의 해시 함수를 사용합니다.

하나는 함수는 최초의 해시값을 얻을 때 사용하고 다른 하나의 함수는 해시 충돌이 일어났을 때 이동할 폭을 얻을 때 사용합니다.

두 원소의 첫번째 해시값이 같더라도 서로 다른 보폭으로 점프하게 만들어서 두번째 해시값까지 같을 확률을 작게 하는 전략입니다.

# 🔒 Secure Hash Algorithm(SHA)
해시 충돌을 해결하는 전략들을 설명드렸지만 사실 좋은 해시함수는 해시 충돌성이 매우 적어야 합니다.
실제 해시 충돌성이 매우 적은 해시 알고리즘인 SHA를 소개해드리겠습니다.

SHA는 미국 국가 안보국(NSA)에 의해 1993년 처음 개발된 해시 알고리즘으로 현재 주로 사용되는 SHA-256, SHA-512와 같은 것들은 사실상 해시 충돌성이 0에 수렴합니다. 

> 256의 의미는 해싱을 하면 2^256개의 해시값 중 하나가 나타난다는 뜻입니다.
SHA는 또한 원소의 값이 아주 조금만 바뀌더라도 생성되는 해시값이 완전히 달라지는 저항성(Resistence)를 갖추고 있어 주어진 해시값에서 원래 입력을 찾기 어렵게 함으로 보안적인 측면에서도 많은 장점을 가진다는 특징이 있습니다.

실제로 아래와 같이 점 하나만 찍어도 해시값이 완전히 달라진답니다.
![](https://velog.velcdn.com/images/libienz/post/1d28f016-63b8-4e84-a853-df13efff43c9/image.png)

또한 아무리 긴 원소도 고정된 길이의 해시값으로 매핑되는, 해시 함수의 특징을 지킨 모습또한 확인할 수 있습니다.
![](https://velog.velcdn.com/images/libienz/post/73f6c2df-7748-41e5-9c21-17f1dcd240be/image.png)

# 🛠️ 해시의 응용
해시 함수 기술은 해시 테이블 뿐만이 아니라 
- 무결성 검사
- 클라우드 스토리지에서 동일한 파일 식별 및 수정된 파일 검출
- 데이터베이스에 비밀번호를 저장할 때 사용
- 블록체인
- Git

등등 다양한 분야에서 응용되고 있습니다.
해시 함수의 개론과, 충돌, 충돌 해결전략, 해시의 응용에 대해서 드린 말씀이 잘 전달되었기를 바랍니다 🫠

# 📖 참고
https://kang-james.tistory.com/136
https://www.youtube.com/watch?v=Rpbj6jMYKag
